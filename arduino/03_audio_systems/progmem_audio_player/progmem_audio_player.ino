/*
 * PROGMEM Audio Player for Arduino UNO
 * HIGH FIDELITY VERSION - Phase Correct PWM for clear speech
 * 
 * Based on Open Music Labs research: Phase Correct PWM has much better
 * fidelity than Fast PWM, especially for speech reproduction
 * - Phase Correct PWM: Superior harmonic distortion characteristics
 * - 32kHz effective frequency: Well above audible, good resolution
 * - Optimized for speech clarity over raw bit depth
 * 
 * Hardware:
 * - Audio output on pin 9 (Timer1 PWM)
 * - RC filter: 1.5kÎ© resistor + 10nF capacitor (10.6kHz cutoff)
 * - Connect filtered output to amplifier
 * 
 * Auto-plays audio - crystal clear speech quality!
 */

#include <avr/pgmspace.h>

// Include the audio data (generated by convert_audio_progmem.py)
#include "audio_data.h"

// Audio playback state
volatile bool isPlaying = false;
volatile uint32_t sampleIndex = 0;
volatile bool audioComplete = false;
volatile uint8_t sampleCounter = 0;

// Audio output pin (Timer1 PWM = Pin 9)
#define AUDIO_PIN 9

void setup() {
  Serial.begin(9600);
  
  // Configure PWM pin as output
  pinMode(AUDIO_PIN, OUTPUT);
  
  // Setup Timer1 for audio output
  setupAudioTimer();
  
  Serial.println("PROGMEM Audio Player - High Fidelity Phase Correct PWM");
  Serial.print("Audio: ");
  Serial.print(AUDIO_SAMPLE_COUNT);
  Serial.print(" samples, ");
  Serial.print(AUDIO_DURATION, 2);
  Serial.println("s duration");
  
  // Auto-start playback after brief delay
  delay(1000);
  startPlayback();
}

void setupAudioTimer() {
  // Timer1 Phase Correct PWM mode for superior audio fidelity
  // Phase Correct PWM: WGM13=1, WGM12=0, WGM11=1, WGM10=0
  TCCR1A = _BV(COM1A1) | _BV(WGM11);              // Clear OC1A on up-count, Phase Correct PWM
  TCCR1B = _BV(WGM13) | _BV(CS10);                // Phase Correct PWM, no prescaler
  
  // INCREASED AMPLITUDE: 20kHz for more resolution and volume
  // ICR1 = F_CPU / (2 * desired_freq) 
  // For 20kHz: ICR1 = 16MHz / (2 * 20kHz) = 400
  // This gives us 400 levels (more amplitude) while staying inaudible
  ICR1 = 399;  // 20kHz effective frequency, 400 levels (better amplitude)
  
  // OCR1A controls PWM duty cycle (audio sample value)
  OCR1A = ICR1 / 2;  // Start with silence (50% duty cycle)
  
  // Enable Timer1 Compare A interrupt
  TIMSK1 = _BV(OCIE1A);
  
  Serial.println("Timer1 Phase Correct PWM: 20kHz, 400 levels, HIGH AMPLITUDE");
}

// Timer1 Compare A interrupt - Phase Correct PWM mode
ISR(TIMER1_COMPA_vect) {
  // In Phase Correct mode, this interrupt fires at 2x the effective frequency
  // 40kHz interrupt rate for 20kHz effective PWM frequency
  // Count every 5th interrupt for 8kHz sample rate (40kHz / 5 = 8kHz)
  sampleCounter++;
  if (sampleCounter >= 5) {
    sampleCounter = 0;
    
    if (isPlaying && !audioComplete) {
      // Read sample from PROGMEM
      uint8_t sample = pgm_read_byte(&audioData[sampleIndex]);
      
      // SOFTWARE VOLUME BOOST: Amplify sample before PWM conversion
      // Convert 8-bit sample to centered around 128 (DC offset removal)
      int16_t centeredSample = (int16_t)sample - 128;
      
      // Apply 2x amplification for louder output
      centeredSample = centeredSample * 4;
      
      // Clamp to prevent overflow
      if (centeredSample > 127) centeredSample = 127;
      if (centeredSample < -128) centeredSample = -128;
      
      // Convert back to unsigned 8-bit
      uint8_t amplifiedSample = (uint8_t)(centeredSample + 128);
      
      // Convert amplified sample to PWM value (0-ICR1)
      // Phase Correct PWM with full amplitude range
      uint16_t pwmValue = ((uint32_t)amplifiedSample * ICR1) / 255;
      OCR1A = pwmValue;
      
      // Advance to next sample
      sampleIndex++;
      
      // Check if we've reached the end
      if (sampleIndex >= AUDIO_SAMPLE_COUNT) {
        isPlaying = false;
        audioComplete = true;
        OCR1A = ICR1 / 2;  // Output silence (50% duty cycle)
      }
    } else {
      // Not playing - output silence
      OCR1A = ICR1 / 2;
    }
  }
}

void startPlayback() {
  Serial.println("ðŸŽµ Starting high-fidelity playback...");
  
  // Reset playback state
  sampleIndex = 0;
  audioComplete = false;
  sampleCounter = 0;
  
  // Start playback
  isPlaying = true;
  
  Serial.print("Playing ");
  Serial.print(AUDIO_SAMPLE_COUNT);
  Serial.print(" samples at ");
  Serial.print(AUDIO_SAMPLE_RATE);
  Serial.println("Hz (Phase Correct PWM)");
}

void loop() {
  // Check if playback completed
  if (audioComplete) {
    Serial.println("âœ… High-fidelity playback complete!");
    audioComplete = false;
    
    // Restart playback after 2 seconds
    delay(2000);
    startPlayback();
  }
  
  delay(100);  // Small delay
} 