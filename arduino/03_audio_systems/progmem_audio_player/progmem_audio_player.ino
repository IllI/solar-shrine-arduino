/*
 * PROGMEM Audio Player for Arduino UNO
 * Plays audio stored directly in flash memory using timer interrupts
 * 
 * MINIMAL FIX: Same working code, just higher PWM frequency
 * - Exact same Timer1 structure that worked
 * - Only change: ICR1 from 1999 (8kHz) to 515 (31kHz)
 * - Same interrupt timing and audio logic
 * 
 * Hardware:
 * - Audio output on pin 9 (Timer1 PWM)
 * - RC filter: 2kÎ© resistor + 10nF capacitor (your current setup)
 * - Connect filtered output to amplifier
 * 
 * Auto-plays audio - clear quality, no squeal!
 */

#include <avr/pgmspace.h>

// Include the audio data (generated by convert_audio_progmem.py)
#include "audio_data.h"

// Audio playback state
volatile bool isPlaying = false;
volatile uint32_t sampleIndex = 0;
volatile bool audioComplete = false;
volatile uint8_t sampleCounter = 0;  // Counter for proper 8kHz timing

// Audio output pin (Timer1 PWM = Pin 9)
#define AUDIO_PIN 9

void setup() {
  Serial.begin(9600);
  
  // Configure PWM pin as output
  pinMode(AUDIO_PIN, OUTPUT);
  
  // Setup Timer1 for audio output
  setupAudioTimer();
  
  Serial.println("PROGMEM Audio Player - Clear Audio, No Squeal");
  Serial.print("Audio: ");
  Serial.print(AUDIO_SAMPLE_COUNT);
  Serial.print(" samples, ");
  Serial.print(AUDIO_DURATION, 2);
  Serial.println("s duration");
  
  // Auto-start playback after brief delay
  delay(1000);
  startPlayback();
}

void setupAudioTimer() {
  // Timer1 Fast PWM mode - EXACT same setup as working version
  // Fast PWM mode: WGM13=1, WGM12=1, WGM11=1, WGM10=0
  TCCR1A = _BV(COM1A1) | _BV(WGM11);              // Clear OC1A on compare match, Fast PWM
  TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10);   // Fast PWM, no prescaler
  
  // ONLY CHANGE: PWM frequency 8kHz â†’ 31kHz (eliminate squeal)
  // OLD (caused squeal): ICR1 = 1999  (8kHz PWM frequency)  
  // NEW (no squeal):     ICR1 = 515   (31kHz PWM frequency)
  ICR1 = 515;  // 31kHz PWM frequency (inaudible)
  
  // OCR1A controls PWM duty cycle (audio sample value)
  OCR1A = ICR1 / 2;  // Start with silence (50% duty cycle)
  
  // Enable Timer1 Compare A interrupt - SAME as working version
  TIMSK1 = _BV(OCIE1A);
  
  Serial.println("Timer1 Fast PWM: 31kHz (no squeal), 8kHz sampling via counter");
}

// Timer1 Compare A interrupt - fires at 31kHz, but we sample at 8kHz
ISR(TIMER1_COMPA_vect) {
  // Count PWM cycles to achieve 8kHz sample rate
  // 31kHz / 8kHz â‰ˆ 4, so update sample every 4th interrupt
  sampleCounter++;
  if (sampleCounter >= 4) {
    sampleCounter = 0;
    
    if (isPlaying && !audioComplete) {
      // Read sample from PROGMEM
      uint8_t sample = pgm_read_byte(&audioData[sampleIndex]);
      
      // Convert 8-bit sample (0-255) to PWM value (0-ICR1)
      uint16_t pwmValue = ((uint32_t)sample * ICR1) / 255;
      OCR1A = pwmValue;
      
      // Advance to next sample
      sampleIndex++;
      
      // Check if we've reached the end
      if (sampleIndex >= AUDIO_SAMPLE_COUNT) {
        isPlaying = false;
        audioComplete = true;
        OCR1A = ICR1 / 2;  // Output silence (50% duty cycle)
      }
    } else {
      // Not playing - output silence
      OCR1A = ICR1 / 2;
    }
  }
}

void startPlayback() {
  Serial.println("ðŸŽµ Starting audio playback...");
  
  // Reset playback state
  sampleIndex = 0;
  audioComplete = false;
  sampleCounter = 0;  // Reset timing counter
  
  // Start playback
  isPlaying = true;
  
  Serial.print("Playing ");
  Serial.print(AUDIO_SAMPLE_COUNT);
  Serial.print(" samples at ");
  Serial.print(AUDIO_SAMPLE_RATE);
  Serial.println("Hz");
}

void loop() {
  // Check if playback completed
  if (audioComplete) {
    Serial.println("âœ… Playback complete!");
    audioComplete = false;
    
    // Restart playback after 2 seconds
    delay(2000);
    startPlayback();
  }
  
  delay(100);  // Small delay
} 